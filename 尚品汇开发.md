137 0000 0000   111111



header footer静态页面完成 

登录页面组件完成 （ 路由单页面跳转）

# Header组件

## Search功能

```js
达到效果：
input 不输入内容时，点搜索，页面路径 http://localhost:8080/#/Search
input 输入内容时123，点搜索，页面路径 http://localhost:8080/#/Search/123

且都要加载Search...组件
```

### 1、html结构

**问题1、：点击搜索，路径会出现`？#`（原因是提交了表单）**

​		`button`按钮如果没有`type`，默认type就是`submit`（表单中的`button`），此时会提交表单。所以，使用from表单时，要将 `@submit.prevent="search"`绑定在from表单上,

```html
<div class="searchArea">
        <form action="###" class="searchForm" @submit.prevent="search">
          <input
            type="text"
            id="autocomplete"
            class="input-error input-xxlarge"
            v-model="searchText"
          />
          <button
            class="sui-btn btn-xlarge btn-danger"
            type="button"
          >
            搜索
          </button>
        </form>
```

### 2、路由跳转路径

```js
search() {
      const { searchText } = this;
   //方案一：字符串拼接
      const params = searchText ? `/${searchText}` : "";
      this.$router.push(`/Search${params}`);
    	//路由配置 inde.js：
    		{
                 path: "/Search/:searchText?",  //:searchText? 可选参数
                 component: Search,
            },
   //方案二：命名路由
    
    },
```

**错误2、重复跳转相同路径会报错**

Uncaught (in promise) NavigationDuplicated

promise未处理 要处理失败 

**重写push和replace**

```js
//router/index.js:
//  重写VueRouter上的push和replace方法
const push = VueRouter.prototype.push;
const replace = VueRouter.prototype.replace;
VueRouter.prototype.push = function (location, onComplete, onAbort) {
  if (onComplete && onAbort) {
    // 如果用户想处理失败，就处理
    return push.call(this, location, onComplete, onAbort);
  }
  // 如果用户不处理失败，给默认值：空函数
  return push.call(this, location, onComplete, () => { });
};
VueRouter.prototype.replace = function (location, onComplete, onAbort) {
  if (onComplete && onAbort) {
    // 如果用户想处理失败，就处理
    return replace.call(this, location, onComplete, onAbort);
  }
  // 如果用户不处理失败，给默认值：空函数
  return replace.call(this, location, onComplete, () => { });
};
```



​	

# Footer组件

## 登录注册时，不显示

#### 1、通过路由路径来判断 。`App.vue` :

```js
 <Footer v-if="isFooterShow" />
     
 data() {
    return {
      isFooterShow: true,
    };
  },
      
 watch:{
    $route:{
      handler(newVal){
        this.isFooterShow=!(newVal.path.includes("/Login") || newVal.path.includes("/Risgter"))
      },
      immediate:true,//一上来就触发
    }
  }
```

#### 2、改进 ：在路由配置里面传定义属性mate

但是当组件下面还组件的时候，有问题

```js
{
	path: "/Login",
      component: Login,
      meta: {
        isFooterShow: true,
     },
}
    
{
  path: "/Risgter",
  component: Register,
  meta: {
    isFooterShow: true,
  },
},
    
<Footer v-if="!$route.mate.isFooterShow" /> 
```



# Login组件

router-link 选中时，默认会有 active-class类名绑定，通过这个类修改选中时的样式

Vue Router的API

# 路由router问题

## 一、路由配置

`npm i Router`

路由配置文件一把定义在router文件夹中

`route/index.js` :在里面写路由配置，暴露出去，组件需要用的时候引入使用即可

```js
import Vue from "vue"
import VurRouter from "vue-router"

import Home from  "./xxx/xxx/Home"

//VueRouter是应用插件，需要安装后使用
//一旦安装了VueRouter（这里Vue,是全局安装），就会给全局安装两个组件<router-link/>
// 和<router-view/>这两个组件，还有给原型上添加一些属性
Vue.use(VueRouter)

 const router new VueRouter({  //定义好了要将路由暴露出去，所以给一个接受范水质
    //在这里买定义路由配置
     routes:[
         {
             path:"/home",  //url栏输入的地址
             component:Home,    //Path组件 ,在定义之前要先引入进来
             //嵌套路由定义：
             children：[
             	{
             		path:"kid",  //这样写会自动补全“/home/kid” 写全也可以，要加  /  
             		component:HomeKid, //HomeKid组件
        		 },
             ],
     		meta:{ 
        //当组件加载显示时，meta参数 会传递到$route中
     		 },
         },
         {
             path："/",         //当路径是  /  的时候
             redirect:"/home"   //请求重定向
         }
     ]
 })

export default router;  //暴露出去后，main.js文件需要使用router
```

`main.js`:

```js
import router from "./router"
new Vue({
	render:(h)=>h(App),
	router,    //使用router
}).$mount('#app')
```

## 二、路由使用

### 1、路由链接跳转

``router-link` 和 `router-view`

```js
//router-link负责切换地址，router-view负责显示组件
<button>
    //to=" " 这里是 key=value形式，value涉及到js数据时， to前面要加 ：
    <router-link to="/home">点击去Home组件</router-link>
</button>
<div>
	<router-view></router-view>     // Home组件会在这里 显示
</div>
```

### 2、编程式导航

​	**主要用来，跳转的时候发送请求的情况下 ，可以使用**

​		**`$route`:用来获取路由参数（params、query）和路由路径path**

​		**`$router`:用来编程式导航**

```js
this.$router.push(path)// 相当于点击路由链接(可以返回到当前路由界面)
this.$router.replace(path)// 用新路由替换当前路由(不可以返回到当前路由界面)
this.$router.back()// 请求(返回)上一个记录路由
this.$router.go(-1)// 请求(返回)上一个记录路由
this.$router.go(1)// 请求下一个记录路由
```

```js
//js里面的写法 : 不写path了 就 
//1、路由配置： /xxx/xxx必选     /xxx/:xxx？ 可选路由参数

//2、使用 ：	<router-link to="/xxx/xxx">
this.$router.push("/xxx/xxx")
this.$routee.push({
	name:"路由名称"   //必须使用命名路由
	params:{}
}) 
```

```js
//search函数
search(){
    const {searchText} = this;
    this.$router.push({
        // path:"/search"   命名路由这里就不用写了
        name:"search",
        params:{
            searchText:searchText,
        },
        query:{...}
    })
}
```



## 三、路由传参方式

### 1、params参数

```js
//路由配置
{ 
	path:"/xxx/:id",   //id 动态路由匹配，能匹配多个地址
    //path:"/xxx/:id？" //加上 ？ 表示可选
	component:xxx,
}
//跳转路由路径
<router-link to "/xxx/1">xxx<router-link/>
//子路由接收参数 :id的参数
this.$route.params.id
//当:id发生的参数发生变化是，需要使用watch监视属性的变化来更新数据
watch：{
    $route:{
        handler(newVal){
        	const id = +newVal.params.id;
            this.msg=this.msg.find((msg)=>msg.id===id)
        }
        immediate:true  //一上来就调用一次
    }
}
```

```js
编程式导航使用params：
this.$touter.push({
	name:"xxx", //必须使用命名路由
})
```





### 2、query方式

```js
//路由连接使用：
<router-link to "/xxx?name="jack&age=18">xxx<router-link/>
//编程式导航传递 :
this.$router.push('/xxx?key=value')
this.$router.push(path:"/xxx",query:{})

//子组件获取
this.$route.query
```

### 3、props

​	将原先的`params`和  `query`参数以``props`的形式传递

```js
//子组件配置
children：[
    {
        path:"kid",    
        component:HomeKid,
        props(route){
        	return {
                ...route.params,
                ...route.query,
            },
        },
     },
 ], 
// 子组件声明接收
props:['id','name','age']
//子组件使用
this.xxx
```

### 4、命名路由

```js
//子组件路由配置
children：[
    {
    	name:'HomeKid', //一般和组件的名字一致
        path:"kid",    
        component:HomeKid,
     },
 ], 
//路由路径
<router-link 
 	to:"{
        name:"HomeKid",要去的那个命名路由
        params:{id:msg.id},
    	query:{
    		name:"jack",
    		age:19,
    	}
    }"       
 >{{xxx}}<router-link />
```

### 5、给相同层级的组件传递公共参数

```js
<button>
    <router-link to="/home">点击去Home组件</router-link>
	<router-link to="/about">点击去About组件</router-link>
</button>
<div>
//只要在这里显示的组件，都可以接收到title ，子组件使用的时候，也要接收一下
	<router-view title="msg"></router-view>    
</div>
//子组件声明接收 后在使用
pros:['key']  
```



①、路由配置： /xxx/xxx必选     /xxx/:xxx？ 可选路由参数

②、使用 ：	<router-link to="/xxx/xxx">

```js
this.$router.push("/xxx/xxx")
this.$routee.push({
	name:"路由名称"   //必须使用命名路由
	params:{}
}) 
```

## nprogress 进度条库

```js
引入进度条插件
import Nprogress from "nprogress"
引入进度条样式
import  “/xxx/xxx.css”

Nprogress.star() 开始  请求拦截器的时候使用
Nprogress.end()  结束  响应拦截器的时候使用（成功 失败都要使用）
```

#  vue add element

饿了么 组件包 App.vue会诶重写 ，先复制一分   第二项按需引入

# Home组件

# 跨域 代理服务器

客户端--> 代理服务器-->目标服务器

代理服务器和服务端地址是一样的。所以直接用·`/` 表示当前服务器地址(发送请求的时候)

```js
//设置代理服务器，解决跨域问题
  devServer: {
    proxy: {
      "/api": {    //以api开头的 地址会转发到目标服务器
        target: "http://182.92.128.115", //目标服务器
        changeOrigin: true, //允许跨域
        // pathRewrite: { // 重写路径
        //   "^/api": "",  //需要api 不能重写这里
        // },
      }
    }
  }
```

# axios发送请求

```js
//1、get方式
axios.get("/xxx/xx/xx")
.then((res)=>{console.log(res.data)})

//2、写成对象方式 ：
axios({
    method:"POST"， //post方式
    url:"http://xxx/xxx/x/x",
    data:{
    	body:"axios手册",
    	postId:2,
	}
})
```



# 拦截器（utils）

下载包 axios    nprogress (进度条)

```js
import axios from "axios";   //引入axios
/* 
  封装axios拦截器
    1. 设置公共的请求地址前缀
    2. 请求拦截器：添加公共参数
    3. 响应拦截器: 
      成功：返回成功的Promise，值为成功的数据
      失败：返回失败的Promise，值为失败的原因
*/
//创建拦截器
const instance = axios.create({
	// http://182.92.128.115设置了代理服务器后，公共路径就改为  /api
  baseURL: "/api",//公共路径 /api表示当前服务器地址  

  headers: {
    // token:"xxx" 登录接口不需要token
  },
});

// 设置请求拦截器
instance.interceptors.request.use(
  (config) => {
    // config 请求的配置对象
    // 将来发送请求（请求地址，请求参数，请求方式等）都会在config中找
    // 开始进度条
    NProgress.start();

    // 修改config，用来添加公共的请求参数
    // if (token) {
    //   config.headers.token = token;
    // }

    return config;
  }
  // 初始化Promise.resolve()返回默认成功的Promise，只会触发成功的回调
  // () => {},
);
// 设置响应拦截器
instance.interceptors.response.use(
  // 响应成功：当响应状态码为 2xx
  (response) => {
    // 进度条结束
    NProgress.done();
    // 判断响应的code是否是200
    if (response.data.code === 200) {
      // 返回成功的响应数据
      return response.data.data;
    }
    const { message } = response.data;
    // 提示错误
    Message.error(message);
    // 功能失败 --> 返回失败的Promise
    return Promise.reject(message);
  },
  // 响应失败：当响应状态码不是 2xx
  (error) => {
    // console.dir(error);
    // 进度条结束
    NProgress.done();
    const message = error.message || "网络错误";
    // 提示错误
    Message.error(message);
    return Promise.reject(message);
  }
);

export default instance;
```

### 2、引入进度条nprogress

```js
//下包 npm i nprogress

//拦截器中引入 
import Nprogress from "nprogress"
//引入进度条样式
import "nprogress/noprogress.css"
//使用位置:
-请求拦截器 ： Nprogress.start();
-响应个拦截器（成功和失败）：NProgress.done();
```

### 3、错误提示弹窗

**`1、vue add elemnt ` 安装包** 

​	连着下载两次会报错，babel.config.js 中修改

​	**会重写App.vue 文件 ，要记得备份 改回来**

```js
import { Message } from "element-ui";
//Message单独引入
//使用：
Message.error(message); //错误弹窗提示
```



# API：公共请求方法

```js
import request from "/utils/request"  // 引入request  ，utils中 我们封装了拦截器

//封装一个发送请求的功能函数
export const reqLogin=()=>{
    request({
        method:'POST',
        url:"/user/passport/login",
        data:{
            //data :post 方法放置请求体参数
            phone,
            password,
        },
        params:{} //放置查询字符窜的参数
    })
}
```





# 配置路径别名

1、根目录创建``vue.config.js` ,

```js
const path = require("path");  //引入path 模块 
moudle.exports={
	linOnSave:false, //关闭所有eslint检查
	//当前配置回合webpack的配置合并
	configureWebpack:{
		resolve:{
			alias:{
				//配置路径别名，引入时可以简写路径了
				"@views":path.resolve(__dirName,"src/views"),
                //表示 @views相当于 "src/views" 目录 
			}
		}
	}
}
```

2、配置路径别名后，再输入@views的路径时，不会显示提示。可以在``jsconfig.json`文件中配置相关的代码，就可以自动提示了

```json
{
    "comilerOptions":{
        "baseUrl":".",
        "paths":{
            "@views/*":["./src/views/*"],
        }
    }
    "exclude":["node_moudles"]
}
```

# TypeNav组件

## 	1、在home中也用，在search中也要使用，所以放入公共组件components中

```js
//TypeNav :
import { reqGetBaseCategoryList } from "@api/home";
data() {
    return {
      categoryList: [], //初始化响应式数据
    };
  },
  
async mounted() {
    //调用发送请求的方法
    const reslut = await reqGetBaseCategoryList();
    this.categoryList = reslut.slice(0, 15);
  },
      
 //结构 插值
 <div
    class="item bo"
    v-for="category in categoryList"
    :key="category.categoryId"
  >
<h3>
  <!-- 一级分类 -->
  <a href="">{{ category.categoryName }}</a>
</h3>
-----------------------------------------------------------------
<dl
  class="fore"
  v-for="child in category.categoryChild"
  :key="child.categoryId"
>
<dt>
<!-- 二级分类 -->
<a href="">{{ child.categoryName }}</a>
</dt>
---------------------------------------------------------------------
 <!-- 三级分类 -->
    <em
      v-for="grandChild in child.categoryChild"
      :key="grandChild.categoryId"
    >
      <a href="">{{ grandChild.categoryName }}</a>
    </em>     
```

```js
//home.js
import request from "@utils/request";

/* 
    获取首页三级list
*/
export const reqGetBaseCategoryList=()=>{
    return request({
        method:"GET",
        url:"/product/getBaseCategoryList",
    })
}
```

## 2、使用vuex管理

`store->index.js`

```js
import Vue from "vue";
import Vuex from "vuex";
import modules from "./modules";    //vuex的模块化

Vue.use(Vuex);

const state = {};
const getters = {};
const actions = {};
const mutations = {};
export default new Vuex.Store({
  state,
  getters,
  actions,
  mutations,
  modules,
})
```

`store->model->index.js`

```js
//汇总所有的模块
import home from "./home"

//统一暴露出去
export default {
  home,
}

```



`store->model->home.js`

将TypeNav的vuex管理模块化，

```js

// home组件的vuex状态
import { reqGetBaseCategoryList } from "@api/home";

export default {
  state: {
    categoryList: [], //首页三级分类 初始化数据
  },
  getters: {},
  actions: {
    async getCategoryList({ commit }) {
      //发送请求
      const categoryList = await reqGetBaseCategoryList();
      //触发mutaions函数
      commit("GET_CATEGORY_LIST", categoryList);
    },
  },
  mutations: {
    GET_CATEGORY_LIST(state, categoryList) {
      //对返回的数据categoryList 进行处理。并更新state.categoryList的数据
      state.categoryList = categoryList.slice(0, 15);
    }
  }
}
```



## 3、路由跳转（跳转到search）

```js
//1、绑定事件goSearch(e) 
 <div class="all-sort-list2" @click="goSearch">
//2、自定义属性
   <div
      class="item bo"
      v-for="category in categoryList"
      :key="category.categoryId"
    >
      <h3>
        <!-- 一级分类 -->  //二级，三级类似
        <!-- categoryname, categoryid, categorytype -->
        <a
          :data-categoryname="category.categoryName"
          :data-categoryid="category.categoryId"
          :data-categorytype="1"
          >{{ category.categoryName }}</a
        >
      </h3>  


goSearch(e) { //根据鼠标点击事件，决定跳转的路径
      //定义函数，接收鼠标事件，categoryname, categoryid, categorytype分别是要给三级标题定义自定义事件的名字
      const { categoryname, categoryid, categorytype } = e.target.dataset;
      if (!categoryname) return; //如果categoryname没有值，直接ruturn
      this.isNavShow = false; //点击搜索后将Nav列表隐藏

      const location = {
        // 发送请求
        name: "search",
        // path: "/search", 后面要加上params参数，所以这里只能用命名路由
        query: { //跳转时，加上query参数，通过自定义属性，来计算的值
          categoryName: categoryname,   
          [`categroy${categorytype}Id`]: categoryid,
        },
      };
      this.$router.push(location);
    },
        
    mounted() {
    this.getCategoryList();
  },
```



## 4、在home显示，在search中滑入显示，滑出隐藏、添加过度效果

## 5、点击跳转时，添加params参数 

```

```

# mock库-模拟数据

## 1、基础使用

```js
npm install mockjs    安装

// 使用 Mock
var Mock = require('mockjs')
var data = Mock.mock({
    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素
    'list|1-10': [{
        // 属性 id 是一个自增数，起始值为 1，每次增 1
        'id|+1': 1
    }]
})
// 输出结果
console.log(JSON.stringify(data, null, 4))
```

```js
// 使用 Mock
var Mock = require('mockjs')
Mock.Random.ctitle();  //随机生成标题（中文）
Mock.Random.color();
Mock.Random.cname();   //随机生成名字
Mock.Random.image();
//当随机数据只有一条是，就不是数组，而是对象
var data = Mock.mock({
  // 属性 list 的值是一个数组，其中含有 1 到 10 个元素
  'list|1-10': [{
    // 属性 id 是一个自增数，起始值为 1，每次增 1
    'id|+1': 1
  }],
  'imgs|1-5': [{
    'id|+1': 1,
    "imgUrl": "@image('200x400','@color')"
  }],
  "title|1-5": [{
    "title": "@ctitle(4)"
  }],
  "news": "@ctitle"
})
// 输出结果
console.log(data)

控制台输出 ：
PS C:\Users\Administrator\Desktop\vue-pc> node .\mock.js
{
  list: [ { id: 1 }, { id: 2 } ],
  imgs: [
    { id: 1, imgUrl: 'http://dummyimage.com/200x400/b079f2' },
    { id: 2, imgUrl: 'http://dummyimage.com/200x400/79f28c' },
    { id: 3, imgUrl: 'http://dummyimage.com/200x400/f27988' },
    { id: 4, imgUrl: 'http://dummyimage.com/200x400/79acf2' }
  ],
  title: [
    { title: '所动打为' },
    { title: '北度叫当' },
    { title: '育构需音' },
    { title: '分那北快' }
  ],
  news: '明老使候'
}
```

## 2、在vue（vuex）中使用

### 1、配置mock地址  mockServer.js

`mockServer.js`

```js
import Mock from "mockjs";
import floors from "./rfloors.json";
import banners from "./rbanners.json";

//请求方式必须是小写，不然拦截不到
Mock.mock("/mock/banners", "get", {
  code: 200,
  "data|4": banners,   // 首页的轮播图
});
Mock.mock("/mock/banners", "get", {
  code: 200,
  "data|4": floors,   
});

```

### 2、配置json数据( 模拟的数据)

​	在mockServer.js里面使用，先导入进去

`rbanners.json`:

```json
[
    {
        "id|+1": 1,
        "imgUrl": "@image('720x450','@color')"
    }
]
```



`rfloors.json`:

```json
[
    {
        "id|+1": 1,
        "name": "@ctitle(4)",
        "keywords|4-8": [
            "@ctitle(3,6)"
        ],
        "imgUrl": "@image()",
        "navList|6-10": [
            {
                "url": "#",
                "text": "@ctitle(2,4)"
            }
        ],
        "carouselList|3": [
            {
                "id|1": 1,
                "imgUrl": "@image('200x100','@color')"
            }
        ],
        "recommendList|4": [
            "@image('200x200', '@color')"
        ],
        "bigImg": "@image('200x200', '@color')"
    }
]
```

## 3、重新封装axios拦截器

​	因为路径写的是  **"/mock/banners"**，所以需要重新配置一个 axios拦截器

```js
Mock.mock("/mock/banners", "get", {
  code: 200,
  "data|4": banners,   // 首页的轮播图
});
```

​	`mockRequest.js`:直接复制`request.js`即可，将其中的`baseUrl`改为 ：`baseURL: "/mock"`

```
const instance = axios.create({
  baseURL: "/mock",
});

```

## 4、封装发送请求的函数（api）

因为是home组件的子组件 ，所以写在**(api)->home.js**中

```js
import mockRequest from "@utils/mockRequest";   //先引入

/**
 * 获取首页轮播图数据
 */ 

//定义发送请求的到 url: "/banners",的函reqGetBanners(),组件中，mounted()里面调用这个函数
export const reqGetBanners = () => { 
  return mockRequest({
    method: "GET",
    url: "/banners",
  })
}
/**
 * 获取首页楼层数据
 */

//定义发送请求的到  url: "/floors",,的函reqGetBanners(),组件中，mounted()里面调用这个函数
export const reqGetFloors = () => {
  return mockRequest({
    method: "GET",
    url: "/floors",
  })
}
```

## 5、vuex中管理数据

`store->modules->home.js`

```js
//1、首先从(api)->home.js 引入两个封装好的发送请求的函数reqGetBanners, reqGetFloors
import { reqGetBaseCategoryList, reqGetBanners, reqGetFloors } from "@api/home";
//2、data中定义数据，初始化，响应式的（会改变界面）
state: {
    categoryList: [], //首页三级分类 初始化数据
    banners: [], //首页轮播图数据
    floorsL: [],//首页顶层数据
  },
//3、actions中发送请求，触发mutations
actions: {
    async getCategoryList({ commit }) {
      //发送请求
      const categoryList = await reqGetBaseCategoryList();
      //触发mutaions函数
      commit("GET_CATEGORY_LIST", categoryList);
    },
    async getBanners({ commit }) {
      //发送请求
      const banners = await reqGetBanners();
      //触发mutaions函数
      commit("REQGET_BANNERS", banners);
    },
    async getFloors({ commit }) {
      //发送请求
      const floors = await reqGetFloors();
      //触发mutaions函数
      commit("REQGET_FLOORS", floors);
    },
},
//4、触发mutations，对数据做修改
mutations: {
    GET_CATEGORY_LIST(state, categoryList) {
      //对返回的数据categoryList 进行处理。并更新state.categoryList的数据
      state.categoryList = categoryList.slice(0, 15);
    },
    REQGET_BANNERS(state, banners) {
      //banners 进行处理。并更新state.banners的数据
      state.banners = banners;
    },
    REQGET_FLOORS(state, floors) {
      //对返回的数据floors进行处理。并更新state.floors的数据
      state.floors = floors;
    },
}
```

## 6、ListContainer（轮播图）组件中使用

```js
import { mapState, mapActions } from "vuex";   //引入 mapState, mapActions 
computed: {
	...mapState({
 		banners: (state) => state.home.banners,//mapState在计算属性中获取
	}),
},
methods: {
	...mapActions(["getBanners"]),//getBanners（）方法，在methods中接收
},
      
mounted() {
	this.getBanners();  //调用函数 getBanners()
},

```



# vuex的模块化（Search组件举例）

## 1、模块化的优点

​	尽可能避免将来合并文件出现的冲突问题

​			store/module/index.js这个文件管来回出现冲突（保留双方的代码）

​	每个页面的数据都会在一个文件中，方便维护

## 2、配置modules

### ①、目录结构

**store目录结构 ： (modules ) 、index.js**

**modules目录结构 ： home.js、search.js、index.js**

### ②、store配置

```js
stroe/index : 
import Vue from  "vue"
import Vuex from  "vuex"
import modules from "./modules" //引入modules文件夹里面的index.js 

Vue.use(Vuex);  //注册vuex
const state={};
const actions={};
const mutations={};
const getters={};

export default new Vuex.Stroe({   //默认导出store 
    stae,
    actions,
    mutations,
    getters,
    modules,
})
```

### ③、modules配置

```js
modules/index.js :   
//这个文件主要是将modules里面的管理各个组件的模块（state、actions、等····）导出

//汇总所有的模块，统一导出
import home from  "./home";
import search from "./search"、

export default {
    home,
    search,
}
```

```js
modules/search.js ： 
//用来管理search组件中的数据和方法，处理更新数据，发送请求等等都在这里统一操作

import {reqGetProduct} from "@api/search"    // 导入 api中 封装的 发送请求的方法

export default {
    state:{    //satate用来初始化响应式数据
        productList:{
            trademarkList: [],
      		attrsList: [],
      		goodsList: [],
        }
    },
    
   /* getters: {
           //对数据进行处理，方便访问
            trademarkList(state) { return state.productList.trademarkList },
            attrsList(state) { return state.productList.attrsList },
            goodsList(state) { return state.productList.goodsList },
  		},
  	*/
    actions:{  
        //对数据进行间接操作，发送请求，一般都在actions里面，他会触发mutations里面的方法，从而修改响应式数据
        
        //定义发送请求的方法，这个方法里面调用 reqGetProduct（api中封装的）
        getProduct({commit},data={}){
            //调用发送请求的方法reqGetProduct（真正的发送请求）
            const productList = reqGetProduct(data); //定义productList，来保存响应回来的数据
            //通过commit来触发mutations对响应的数据更新
            commit('GET_PRODUCT',productList); // GET_PRODUCT 就是mutations中的方法，productList（返回的响应）当做参数传递过去
        }
    },
    mutations:{
        GET_PRODUCT(state,productList){  //state就是初始化响应式数据
            state.productList = productList  //  将state中的productList 赋值为响应回来的productList
        }
    }
   
   
}
```

```js
modules/home.js
// home组件的vuex状态
import { reqGetBaseCategoryList, reqGetBanners, reqGetFloors } from "@api/home";

export default {
  state: {
   	categoryList: [], //首页三级分类 初始化数据
    banners: [], //首页轮播图数据
    floors: [],//首页顶层数据
  },
  getters: {},
  actions: {
    async getCategoryList({ commit }) {
      //发送请求
      const categoryList = await reqGetBaseCategoryList();
      //触发mutaions函数
      commit("GET_CATEGORY_LIST", categoryList);
    },
    async getBanners({ commit }) {
      //发送请求
      const banners = await reqGetBanners();
      //触发mutaions函数
      commit("REQGET_BANNERS", banners);
    },
    async getFloors({ commit }) {
      //发送请求
      const floors = await reqGetFloors();
      //触发mutaions函数
      commit("REQGET_FLOORS", floors);
    },
  },
  mutations: {
    GET_CATEGORY_LIST(state, categoryList) {
      //对返回的数据categoryList 进行处理。并更新state.categoryList的数据
      state.categoryList = categoryList.slice(0, 15);
    },
    REQGET_BANNERS(state, banners) {
      //banners 进行处理。并更新state.banners的数据
      state.banners = banners;
    },
    REQGET_FLOORS(state, floors) {
      //对返回的数据floors进行处理。并更新state.floors的数据
      state.floors = floors;
    },
  }
}

```

### ④、search组件使用数据

```js
import { mapState, mapActions, mapGetters } from "vuex";   //首先从vuex上导入，需要使用的方法
//解构赋值，拿到需要用的方法和数据
computed: { //getters数据在computed中获取
    //解构获取数据   这里是通过getters获取数据，而不是state，因为提前对数据进行了处理。
    ...mapGetters(["trademarkList", "attrsList"]),
  },
  methods: {
    //结构获取发送请求的函数getProduct  ，这个函数是在mapActions里面定义的发送请求的函数
    ...mapActions(["getProduct"]),
  },
  //发送请的方法在mounted中调用，因为是发送请求的 ，一上来就发送请求
  mounted() {
    //组件加载时调用发送请求的函数
    this.getProduct();
  },   
      
这样后，就能取到数据【"trademarkList", "attrsList"】，因为这里为了便于访问，在search.js中，定义定义了getters，对数据进行了处理，处理如下：
      
getters: {
    //对数据进行处理，方便访问
    trademarkList(state) { return state.productList.trademarkList },
    attrsList(state) { return state.productList.attrsList },
    goodsList(state) { return state.productList.goodsList },
},
```



## 3、vuex管理的数据结构

```js
{
	testCount:0,    //总数据
	home:{ //分模块数据,通过this.$store.home访问
        categoryList: [], //首页三级分类 初始化数据
        banners: [], //首页轮播图数据
        floors: [],//首页顶层数据
    },
    search:{
        categoryList: [], //首页三级分类 初始化数据
        banners: [], //首页轮播图数据
        floors: [],//首页顶层数据
    },
	....
}
        
在home组件中，通过mapState 解构获取数据，使用this.home.xxxx获取数据
import { mapState} from "vuex";    
state:{
    ...mapState({
        home:(state)=>state.home.banners,
    })
}
```



# 轮播图Carousel公共组件

## 1、公共组件（轮播图）

```vue
<template>
  <div class="swiper-container" ref="swiper">
    <div class="swiper-wrapper">
      <div
        class="swiper-slide"
        v-for="carousel in carouselList"
        :key="carousel.id"
      >
        <img :src="carousel.imgUrl" />
      </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
  </div>
</template>

```

```vue
<script>
// 1. 引入swiper两个文件
import Swiper, { Navigation, Pagination, Autoplay } from "swiper";
import "swiper/swiper-bundle.min.css";

// https://swiperjs.com/get-started/
// Swiper6默认只有核心轮播图功能，其他功能没有
// 要使用其他功能，需要先加载
Swiper.use([Navigation, Pagination, Autoplay]);
export default {
  name: "Carousel",
  props: {              //接收参数,在使用该组件时，需要传入参数
    carouselList: {
      type: Array,
      required: true,
    },
  },
  methods: {
    initSwiper() {
      // 使用 this.$refs.swiper 取代 .swiper-container
      // 使用 this.$refs.swiper 才能保证轮播图组件使用的自己的swiper
      this.swiper = new Swiper(this.$refs.swiper, {
        loop: true, // 循环模式选项
        autoplay: {  //要手动引入轮播事件     autoplay ：true  默认设置 
          delay: 1000, //轮播时间
          disableOnInteraction: false, //点击按钮计时器也不会清除
        },

        // 如果需要分页器,小圆点
        pagination: {
          el: ".swiper-pagination",
          clickable: true, //是否可点击
        },

        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      });
    },
  },
  watch: {
    carouselList() {   //模拟数据里面的 ·
      // [] --> 最终的数据 数据发生变化才会触发
      // 轮播图DOM元素要渲染完成 --> 轮播图数据
      // watch为了确保有轮播图数据
      // this.$nextTick为了确保轮播图数据已经渲染成DOM元素

      // 确保：swiper不能new多次
      if (this.swiper) return;
      this.$nextTick(() => {
        this.initSwiper();
      });
    },
  },
  mounted() {
    if (!this.carouselList.length) return;
    // 等当前用户界面更新完毕，在触发其中的回调函数
    this.initSwiper();
  },
};
</script>

<style>
</style>
```

## 2、轮播图思路

### 1、在哪里new Swiper

​			在组件的mounted中去new Swiper，为了保证DOM 结构先生成，此时Awiper才能获取到DOM 元素，从而生成轮播图

### 2、轮播图数据问题

​			如果在mounted直接new Swiper，此时还没有获取到数据（banners），因为此时mounted中刚刚发送请求，轮播图数据还没有生成没所以失败

```js
mounted() {
    this.getBanners();
    new Swiper....     //这里获取不到banners数据，也生成不了
  },
```

要等轮播图图片数据请求回来，在 new Swiper。await this.getBanners() --> 等待 vuex 将数据更新完毕，再执行后面代码，action 函数如果返回一个 promise 对象，await 就能等待 action 和 mutation 函数全部做完直到数据更新（可以通过打印调试看现象）

```js
async mounted() {
   await this.getBanners();
   new Swiper....     //这里可以获取到banners数据
},
```

### 3、轮播图页面DOM问题

​	此时虽然轮播图数据有了，但是 DOM 结构没有。因为**更新用户界面都是异步的**，所以要等同步全部执行完，在去更新，此时有两个方案，

#### 	①、**方案一：定时器**

​		通过定时器将 new Swiper 添加宏任务队列，而更新用户界面是微任务队列
所以是先更新用户界面，此时就有 DOM 结构
再 new Swiper，此时就 OK

```js
async mounted() {
   await this.getBanners();
   setTimeout(() => {
      new Swiper.....       //这里创建轮播图，数据有了，DOM 结构也有了
    }, 0);
},


```

​		②、方案二：`this$nectTick(()=>{})`函数或者 `Vue.nextTick(() => {})`

```js
async mounted() {
   await this.getBanners();
   this$nectTick(()=>{
   		new Swiper.....   
   })
},
```

### 4、两次渲染轮播图（封装组件，引入使用了现在）

#### ①、ListContainer组件的轮播图使用情况

​		上面说的都是在 需要使用轮播图的组件内使用，由于轮播图多个地方使用，所以封装轮播图组件Carousel，**new Swiper在Carousel中的mounted中实现**，轮播图会渲染两次，第一个渲染时（这里举例子是ListContainer组件中，使用子组件Carousel，会导致的情况），banners数据还是[ ] ,第二次才有数据，而封装后的轮播图组件，第一次就会触发mounted，此时banners数据还没生成，渲染失败

```html
<div class="center">
    <!--banner轮播-->
    <Carousel :carouselList="banners" />   //当成组件使用时，banners还是空的就会渲染一次
 </div>
```

所以，在封装组件的时候，不能用mounted，**要用watch监听 carouselList 的变化**

- 第一次 banners 数据是[ ]，是**数据初始化**，不会触发
- 第二次 banners 才有数据，会触发 watch，此时在这里初始化 Swiper 就有数据

```js
//1. ListContainer组件 一上来没有数据 -- 触发watch
watch: {
    carouselList() {
      this.$nextTick(() => {      
      	if (this.swiper) return; // 确保：swiper不能new多次
        new Swiper.....
      });
    },
  },
```

#### ②、Floor组件使用轮播图插件的情况

​	**Floor 组件是等待数据加载成功再进行遍历渲染的**，所以轮播图一上来就有数据，第一次 banners 数据就有了，不会触发 watch，所以不能 new Swiper。

​		此时需要在**mounted 中来判断数据是否存在**，然后 new Swiper。mounted 代表数据已经渲染完成 DOM 元素，所以不需要加 this.\$nextTick

```js
// 2. Floor  一上来就有数据 -- mounted   
mounted() {
    if (!this.carouselList.length) return;
    new Swiper.....
  },
```

#### ④、new Swiper函数

```js
initSwiper() {
      // 使用 this.$refs.swiper 取代 .swiper-container
      // 使用 this.$refs.swiper 才能保证轮播图组件使用的自己的swiper
      this.swiper = new Swiper(this.$refs.swiper, {
        loop: true, // 循环模式选项
        autoplay: {
          // 自动轮播
          delay: 2000, // 轮播间隔时间
          disableOnInteraction: false, // 当用户点击下一页时，仍会开启自动轮播
        },
        // 如果需要分页器
        pagination: {
          el: ".swiper-pagination",
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      });
    },
```



## 3、轮播图swiper注意事项

Swiper 6 需要手动感引入其他插件才能使用

```js
import Swiper,{Navigation,Pagination,Autoplay} from "swiper"
imort "swiper/swiper-bundle.min.css";   //样式 

Swiper.use([Navigation, Pagination, Autoplay]); //注册后可以使用
```



# Searach组件

## 一、页面数据展示

### 	1、TypeNav 子组件

​				这个是左侧的分类栏，直接导入组件使用即可

### 	2、search组件点击搜索后，左侧的大分类

```html
<div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <li class="with-x" v-show="options.keyword">
              {{ options.keyword }}
              <i @click="delKeyword">×</i>
            </li>
            <li class="with-x" v-show="options.categoryName">
              {{ options.categoryName }}
              <i @click="delCategoryName">×</i>
            </li>
            <li class="with-x" v-show="options.trademark">
              {{ options.trademark.split(":")[1] }}
              <i @click="delTrademark">×</i>
            </li>
          </ul>
        </div>
```





## 二、点击Typenav组件、input搜索框

API参数 ：

| 参数名称     | 类型   | 是否必选 | 描述                                                         |
| ------------ | ------ | -------- | :----------------------------------------------------------- |
| category1Id  | string | N        | 一级分类ID                                                   |
| category2Id  | string | N        | 二级分类ID                                                   |
| category3Id  | string | N        | 三级分类ID                                                   |
| categoryName | string | N        | 分类名称                                                     |
| keyword      | string | N        | 搜索关键字                                                   |
| props        | Array  | N        | 商品属性的数组: ["属性ID:属性值:属性名"]示例: ["2:6.0～6.24英寸:屏幕尺寸"] |
| trademark    | string | N        | 品牌: "ID:品牌名称"示例: "1:苹果"                            |
| order        | string | N        | 排序方式 1: 综合,2: 价格 asc: 升序,desc: 降序  示例: "1:desc" |
| pageNo       | number | N        | 页码                                                         |
| pageSize     | number | N        | 每页数量                                                     |

实现功能：

​	**①、点击Typenav组件分类，category1Id、category2Id、category3Id，获取到相关的物品。**

​	**②、input输入关键字keyword（之前定义的 是 searchText），获取相关的物品**

### **0、实现是通过监听 路径 中URL的变化，然后发送请求**

```js
watch: {
    $route() {
      //对$route监视，如果发生了变化（点击了选项，使params和query发生了变化）
      this.updateProductList(); //获取params、query参数，并对data中的进行修改，然后在发送请求
    },
  },
```

watch也可以写成下面的样式，这样mounted中就不用再发送请求了

```js
watch:{
	$route(){
		handler(){
			this.updateProductList();
		},
		immediate:true //一上来就触发一次
	}
},
```



```js
import { mapState, mapActions, mapGetters } from "vuex";

data() {
    return {
      options: {
        category1Id: "", // 一级分类id
        category2Id: "", // 二级分类id
        category3Id: "", // 三级分类id
        categoryName: "", // 分类名称
        keyword: "", // 搜索内容（搜索关键字）
        order: "", // 排序方式：1：综合排序  2：价格排序   asc 升序  desc 降序
        pageNo: 1, // 分页的页码（第几页）
        pageSize: 5, // 分页的每页商品数量
        props: [], // 商品属性
        trademark: "", // 品牌
      },
    };
  },
```

### 2、获取参数，调用发送请求的函数（mapActions）

```js
mounted() { //组件加载时，也需要发送请求
    this.updateProductList();  //定义一个函数，将获取参数，发送请求实现
  },
```

### 3、updateProductList()

```js
methods:{
    ...mapActions(["getProduct"]),  //这是结构出来的发送请求的函数      
    updateProductList() {  
          //定义一个 根据URL来修改options的函数，并发送请求（params参数和query参数）
          const { searchText: keyword } = this.$route.params;
          const {
            category1Id,
            category2Id,
            category3Id,
            categoryName,
          } = this.$route.query;
          const options = {
            ...this.options, //先把data中options的初始化参数都拿到
            keyword,        //$route.params 、$route.query里面要是有值得话，会
            category1Id,	//将options中的参数覆盖
            category2Id,
            category3Id,
            categoryName,
          };
          this.options = options;  //将data中的options修改，后面还有删除操作要使用，
          this.getProduct(options);  //带参数发送请求
   },
}

```

## 综合、价格实现

```js
<li :class="{ active: true }" @click="setOrder">
 //写成对象形式  {value:true},true,value 生效
```

综合 ：

初始化 ：`order: "1:asc",`

