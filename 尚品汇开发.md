137 0000 0000   111111



header footer静态页面完成 

登录页面组件完成 （ 路由单页面跳转）

# Header组件

## Search功能

```js
达到效果：
input 不输入内容时，点搜索，页面路径 http://localhost:8080/#/Search
input 输入内容时123，点搜索，页面路径 http://localhost:8080/#/Search/123

且都要加载Search...组件
```

### 1、html结构

**问题1、：点击搜索，路径会出现`？#`（原因是提交了表单）**

​		`button`按钮如果没有`type`，默认type就是`submit`（表单中的`button`），此时会提交表单。所以，使用from表单时，要将 `@submit.prevent="search"`绑定在from表单上,

```html
<div class="searchArea">
        <form action="###" class="searchForm" @submit.prevent="search">
          <input
            type="text"
            id="autocomplete"
            class="input-error input-xxlarge"
            v-model="searchText"
          />
          <button
            class="sui-btn btn-xlarge btn-danger"
            type="button"
          >
            搜索
          </button>
        </form>
```

### 2、路由跳转路径

```js
search() {
      const { searchText } = this;
   //方案一：字符串拼接
      const params = searchText ? `/${searchText}` : "";
      this.$router.push(`/Search${params}`);
    	//路由配置 inde.js：
    		{
                 path: "/Search/:searchText?",  //:searchText? 可选参数
                 component: Search,
            },
   //方案二：命名路由
    
    },
```

**错误2、重复跳转相同路径会报错**

Uncaught (in promise) NavigationDuplicated

promise未处理 要处理失败 

**重写push和replace**

```js
//router/index.js:
//  重写VueRouter上的push和replace方法
const push = VueRouter.prototype.push;
const replace = VueRouter.prototype.replace;
VueRouter.prototype.push = function (location, onComplete, onAbort) {
  if (onComplete && onAbort) {
    // 如果用户想处理失败，就处理
    return push.call(this, location, onComplete, onAbort);
  }
  // 如果用户不处理失败，给默认值：空函数
  return push.call(this, location, onComplete, () => { });
};
VueRouter.prototype.replace = function (location, onComplete, onAbort) {
  if (onComplete && onAbort) {
    // 如果用户想处理失败，就处理
    return replace.call(this, location, onComplete, onAbort);
  }
  // 如果用户不处理失败，给默认值：空函数
  return replace.call(this, location, onComplete, () => { });
};
```



​	

# Footer组件

## 登录注册时，不显示

#### 1、通过路由路径来判断 。`App.vue` :

```js
 <Footer v-if="isFooterShow" />
     
 data() {
    return {
      isFooterShow: true,
    };
  },
      
 watch:{
    $route:{
      handler(newVal){
        this.isFooterShow=!(newVal.path.includes("/Login") || newVal.path.includes("/Risgter"))
      },
      immediate:true,//一上来就触发
    }
  }
```

#### 2、改进 ：在路由配置里面传定义属性mate

但是当组件下面还组件的时候，有问题

```js
{
	path: "/Login",
      component: Login,
      meta: {
        isFooterShow: true,
     },
}
    
{
  path: "/Risgter",
  component: Register,
  meta: {
    isFooterShow: true,
  },
},
    
<Footer v-if="!$route.mate.isFooterShow" /> 
```



# Login组件

router-link 选中时，默认会有 active-class类名绑定，通过这个类修改选中时的样式

Vue Router的API

# 路由router问题

## 一、路由配置

`npm i Router`

路由配置文件一把定义在router文件夹中

`route/index.js` :在里面写路由配置，暴露出去，组件需要用的时候引入使用即可

```js
import Vue from "vue"
import VurRouter from "vue-router"

import Home from  "./xxx/xxx/Home"

//VueRouter是应用插件，需要安装后使用
//一旦安装了VueRouter（这里Vue,是全局安装），就会给全局安装两个组件<router-link/>
// 和<router-view/>这两个组件，还有给原型上添加一些属性
Vue.use(VueRouter)

 const router new VueRouter({  //定义好了要将路由暴露出去，所以给一个接受范水质
    //在这里买定义路由配置
     routes:[
         {
             path:"/home",  //url栏输入的地址
             component:Home,    //Path组件 ,在定义之前要先引入进来
             //嵌套路由定义：
             children：[
             	{
             		path:"kid",  //这样写会自动补全“/home/kid” 写全也可以，要加  /  
             		component:HomeKid, //HomeKid组件
        		 },
             ],
     		meta:{ 
        //当组件加载显示时，meta参数 会传递到$route中
     		 },
         },
         {
             path："/",         //当路径是  /  的时候
             redirect:"/home"   //请求重定向
         }
     ]
 })

export default router;  //暴露出去后，main.js文件需要使用router
```

`main.js`:

```js
import router from "./router"
new Vue({
	render:(h)=>h(App),
	router,    //使用router
}).$mount('#app')
```

## 二、路由使用

### 1、路由链接跳转

``router-link` 和 `router-view`

```js
//router-link负责切换地址，router-view负责显示组件
<button>
    //to=" " 这里是 key=value形式，value涉及到js数据时， to前面要加 ：
    <router-link to="/home">点击去Home组件</router-link>
</button>
<div>
	<router-view></router-view>     // Home组件会在这里 显示
</div>
```

### 2、编程式导航

​	**主要用来，跳转的时候发送请求的情况下 ，可以使用**

​		**`$route`:用来获取路由参数（params、query）和路由路径path**

​		**`$router`:用来编程式导航**

```js
this.$router.push(path)// 相当于点击路由链接(可以返回到当前路由界面)
this.$router.replace(path)// 用新路由替换当前路由(不可以返回到当前路由界面)
this.$router.back()// 请求(返回)上一个记录路由
this.$router.go(-1)// 请求(返回)上一个记录路由
this.$router.go(1)// 请求下一个记录路由
```

```js
//js里面的写法 : 不写path了 就 
//1、路由配置： /xxx/xxx必选     /xxx/:xxx？ 可选路由参数

//2、使用 ：	<router-link to="/xxx/xxx">
this.$router.push("/xxx/xxx")
this.$routee.push({
	name:"路由名称"   //必须使用命名路由
	params:{}
}) 
```

```js
//search函数
search(){
    const {searchText} = this;
    this.$router.push({
        // path:"/search"   命名路由这里就不用写了
        name:"search",
        params:{
            searchText:searchText,
        },
        query:{...}
    })
}
```



## 三、路由传参方式

### 1、params参数

```js
//路由配置
{ 
	path:"/xxx/:id",   //id 动态路由匹配，能匹配多个地址
	component:xxx,
}
//跳转路由路径
<router-link to "/xxx/1">xxx<router-link/>
//子路由接收参数 :id的参数
this.$route.params.id
//当:id发生的参数发生变化是，需要使用watch监视属性的变化来更新数据
watch：{
    $route:{
        handler(newVal){
        	const id = +newVal.params.id;
            this.msg=this.msg.find((msg)=>msg.id===id)
        }
        immediate:true  //一上来就调用一次
    }
}
```

```js
编程式导航使用params：
this.$touter.push({
	name:"xxx", //必须使用命名路由
	query:{...},
})
```





### 2、query方式

```js
//路由连接使用：
<router-link to "/xxx?name="jack&age=18">xxx<router-link/>
//编程式导航传递 :
this.$router.push('/xxx?key=value')
this.$router.push(path:"/xxx",query:{})

//子组件获取
this.$route.query
```

### 3、props

​	将原先的`params`和  `query`参数以``props`的形式传递

```js
//子组件配置
children：[
    {
        path:"kid",    
        component:HomeKid,
        props(route){
        	return {
                ...route.params,
                ...route.query,
            },
        },
     },
 ], 
// 子组件声明接收
props:['id','name','age']
//子组件使用
this.xxx
```

### 4、命名路由

```js
//子组件路由配置
children：[
    {
    	name:'HomeKid', //一般和组件的名字一致
        path:"kid",    
        component:HomeKid,
     },
 ], 
//路由路径
<router-link 
 	to:"{
        name:"HomeKid",要去的那个命名路由
        params:{id:msg.id},
    	query:{
    		name:"jack",
    		age:19,
    	}
    }"       
 >{{xxx}}<router-link />
```

### 5、给相同层级的组件传递公共参数

```js
<button>
    <router-link to="/home">点击去Home组件</router-link>
	<router-link to="/about">点击去About组件</router-link>
</button>
<div>
//只要在这里显示的组件，都可以接收到title ，子组件使用的时候，也要接收一下
	<router-view title="msg"></router-view>    
</div>
//子组件声明接收 后在使用
pros:['key']  
```



①、路由配置： /xxx/xxx必选     /xxx/:xxx？ 可选路由参数

②、使用 ：	<router-link to="/xxx/xxx">

```js
this.$router.push("/xxx/xxx")
this.$routee.push({
	name:"路由名称"   //必须使用命名路由
	params:{}
}) 
```

## nprogress 进度条库

```js
引入进度条插件
import Nprogress from "nprogress"
引入进度条样式
import  “/xxx/xxx.css”

Nprogress.star() 开始  请求拦截器的时候使用
Nprogress.end()  结束  响应拦截器的时候使用（成功 失败都要使用）
```

#  vue add element

饿了么 组件包 App.vue会诶重写 ，先复制一分   第二项按需引入

# Home组件

# 跨域 代理服务器

客户端--> 代理服务器-->目标服务器

代理服务器和服务端地址是一样的。所以直接用·`/` 表示当前服务器地址(发送请求的时候)

```js
//设置代理服务器，解决跨域问题
  devServer: {
    proxy: {
      "/api": {    //以api开头的 地址会转发到目标服务器
        target: "http://182.92.128.115", //目标服务器
        changeOrigin: true, //允许跨域
        // pathRewrite: { // 重写路径
        //   "^/api": "",  //需要api 不能重写这里
        // },
      }
    }
  }
```

# axios发送请求

```js
//1、get方式
axios.get("/xxx/xx/xx")
.then((res)=>{console.log(res.data)})

//2、写成对象方式 ：
axios({
    method:"POST"， //post方式
    url:"http://xxx/xxx/x/x",
    data:{
    	body:"axios手册",
    	postId:2,
	}
})
```



# 拦截器（utils）

```js
import axios from "axios";   //引入axios
/* 
  封装axios拦截器
    1. 设置公共的请求地址前缀
    2. 请求拦截器：添加公共参数
    3. 响应拦截器: 
      成功：返回成功的Promise，值为成功的数据
      失败：返回失败的Promise，值为失败的原因
*/
//创建拦截器
const instance = axios.create({
	// http://182.92.128.115设置了代理服务器后，公共路径就改为  /api
  baseURL: "/api",//公共路径 /api表示当前服务器地址  

  headers: {
    // token:"xxx" 登录接口不需要token
  },
});

// 设置请求拦截器
instance.interceptors.request.use(
  (config) => {
    // config 请求的配置对象
    // 将来发送请求（请求地址，请求参数，请求方式等）都会在config中找
    // 开始进度条
    NProgress.start();

    // 修改config，用来添加公共的请求参数
    // if (token) {
    //   config.headers.token = token;
    // }

    return config;
  }
  // 初始化Promise.resolve()返回默认成功的Promise，只会触发成功的回调
  // () => {},
);
// 设置响应拦截器
instance.interceptors.response.use(
  // 响应成功：当响应状态码为 2xx
  (response) => {
    // 进度条结束
    NProgress.done();
    // 判断响应的code是否是200
    if (response.data.code === 200) {
      // 返回成功的响应数据
      return response.data.data;
    }
    const { message } = response.data;
    // 提示错误
    Message.error(message);
    // 功能失败 --> 返回失败的Promise
    return Promise.reject(message);
  },
  // 响应失败：当响应状态码不是 2xx
  (error) => {
    // console.dir(error);
    // 进度条结束
    NProgress.done();
    const message = error.message || "网络错误";
    // 提示错误
    Message.error(message);
    return Promise.reject(message);
  }
);

export default instance;
```

### 2、引入进度条nprogress

```js
//下包 npm i nprogress

//拦截器中引入 
import Nprogress from "nprogress"
//引入进度条样式
import "nprogress/noprogress.css"
```

### 3、错误提示弹窗

**`1、vue add elemnt ` 安装包** 

​	**会重写App.vue 文件 ，要记得备份 改回来**

# API：公共请求方法

```js
import request from "/utils/request" //引入request

//封装一个发送请求的功能函数
export const reqLogin=()=>{
    request({
        method:'POST',
        url:"/user/passport/login",
        data:{
            //data :post 方法放置请求体参数
            phone,
            password,
        },
        params:{} //放置查询字符窜的参数
    })
}
```





# 配置路径别名

1、根目录创建``vue.config.js` ,

```js
const path = require("path");  //引入path 模块 
moudle.exports={
	linOnSave:false, //关闭所有eslint检查
	//当前配置回合webpack的配置合并
	configureWebpack:{
		resolve:{
			alias:{
				//配置路径别名，引入时可以简写路径了
				"@views":path.resolve(__dirName,"src/views"),
                //表示 @views相当于 "src/views" 目录 
			}
		}
	}
}
```

2、配置路径别名后，再输入@views的路径时，不会显示提示。可以在``jsconfig.json`文件中配置相关的代码，就可以自动提示了

```json
{
    "comilerOptions":{
        "baseUrl":".",
        "paths":{
            "@views/*":["./src/views/*"],
        }
    }
    "exclude":["node_moudles"]
}
```

# TypeNav组件 

​	在home中也用，在search中也要使用，所以放入公共组件components中

